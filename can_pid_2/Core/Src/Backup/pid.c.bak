/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    pid.c
  * @brief   PID控制器实现
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "pid.h"

/* Private includes ----------------------------------------------------------*/

/* Private typedef -----------------------------------------------------------*/

/* Private define ------------------------------------------------------------*/

/* Private macro -------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/

/* Private function prototypes -----------------------------------------------*/

/* Private user code ---------------------------------------------------------*/

/**
  * @brief  初始化PID控制器
  * @param  pid: PID控制器结构体指针
  * @param  kp: 比例系数
  * @param  ki: 积分系数
  * @param  kd: 微分系数
  * @param  output_max: 输出最大值
  * @param  output_min: 输出最小值
  * @retval None
  */
void PID_Init(PID_Controller_t *pid, float kp, float ki, float kd, 
              float output_max, float output_min)
{
    pid->kp = kp;
    pid->ki = ki;
    pid->kd = kd;
    pid->target = 0.0f;
    pid->current = 0.0f;
    pid->error = 0.0f;
    pid->last_error = 0.0f;
    pid->integral = 0.0f;
    pid->output = 0.0f;
    pid->output_max = output_max;
    pid->output_min = output_min;
    pid->integral_max = output_max * 0.5f;  // 积分限幅为输出限幅的一半
    pid->integral_min = output_min * 0.5f;
}

/**
  * @brief  设置PID目标值
  * @param  pid: PID控制器结构体指针
  * @param  target: 目标值
  * @retval None
  */
void PID_SetTarget(PID_Controller_t *pid, float target)
{
    pid->target = target;
}

/**
  * @brief  PID计算函数
  * @param  pid: PID控制器结构体指针
  * @param  current: 当前值
  * @retval PID输出值
  */
float PID_Calculate(PID_Controller_t *pid, float current)
{
    float p_out, i_out, d_out;
    
    pid->current = current;
    pid->error = pid->target - pid->current;
    
    // 比例项
    p_out = pid->kp * pid->error;
    
    // 积分项（带限幅和抗饱和）
    pid->integral += pid->error;
    
    // 积分限幅
    if (pid->integral > pid->integral_max) {
        pid->integral = pid->integral_max;
    } else if (pid->integral < pid->integral_min) {
        pid->integral = pid->integral_min;
    }
    
    i_out = pid->ki * pid->integral;
    
    // 微分项
    d_out = pid->kd * (pid->error - pid->last_error);
    
    // 计算总输出
    pid->output = p_out + i_out + d_out;
    
    // 输出限幅
    if (pid->output > pid->output_max) {
        pid->output = pid->output_max;
    } else if (pid->output < pid->output_min) {
        pid->output = pid->output_min;
    }
    
    // 更新上一次误差
    pid->last_error = pid->error;
    
    return pid->output;
}

/**
  * @brief  重置PID控制器
  * @param  pid: PID控制器结构体指针
  * @retval None
  */
void PID_Reset(PID_Controller_t *pid)
{
    pid->error = 0.0f;
    pid->last_error = 0.0f;
    pid->integral = 0.0f;
    pid->output = 0.0f;
}

/* USER CODE END 1 */


/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    can.c
  * @brief   This file provides code for the configuration
  *          of the CAN instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "can.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

CAN_HandleTypeDef hcan;

// 电机反馈数据数组
motor_feedback_t motor_feedback[4] = {{0}};

/* CAN init function */
void MX_CAN_Init(void)
{

  /* USER CODE BEGIN CAN_Init 0 */

  /* USER CODE END CAN_Init 0 */

  /* USER CODE BEGIN CAN_Init 1 */

  /* USER CODE END CAN_Init 1 */
  hcan.Instance = CAN1;
  hcan.Init.Prescaler = 72;
  hcan.Init.Mode = CAN_MODE_NORMAL;
  hcan.Init.SyncJumpWidth = CAN_SJW_2TQ;
  hcan.Init.TimeSeg1 = CAN_BS1_6TQ;
  hcan.Init.TimeSeg2 = CAN_BS2_7TQ;
  hcan.Init.TimeTriggeredMode = DISABLE;
  hcan.Init.AutoBusOff = DISABLE;
  hcan.Init.AutoWakeUp = DISABLE;
  hcan.Init.AutoRetransmission = DISABLE;
  hcan.Init.ReceiveFifoLocked = DISABLE;
  hcan.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN_Init 2 */
  
  // 配置CAN过滤器
  CAN_FilterTypeDef can_filter;
  can_filter.FilterBank = 0;
  can_filter.FilterMode = CAN_FILTERMODE_IDMASK;
  can_filter.FilterScale = CAN_FILTERSCALE_32BIT;
  can_filter.FilterIdHigh = 0x0000;
  can_filter.FilterIdLow = 0x0000;
  can_filter.FilterMaskIdHigh = 0x0000;
  can_filter.FilterMaskIdLow = 0x0000;
  can_filter.FilterFIFOAssignment = CAN_RX_FIFO0;
  can_filter.FilterActivation = ENABLE;
  can_filter.SlaveStartFilterBank = 14;
  
  if (HAL_CAN_ConfigFilter(&hcan, &can_filter) != HAL_OK)
  {
    Error_Handler();
  }
  
  // 启动CAN
  if (HAL_CAN_Start(&hcan) != HAL_OK)
  {
    Error_Handler();
  }
  
  // 激活CAN接收中断
  if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
  {
    Error_Handler();
  }
  
  /* USER CODE END CAN_Init 2 */

}

void HAL_CAN_MspInit(CAN_HandleTypeDef* canHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(canHandle->Instance==CAN1)
  {
  /* USER CODE BEGIN CAN1_MspInit 0 */

  /* USER CODE END CAN1_MspInit 0 */
    /* CAN1 clock enable */
    __HAL_RCC_CAN1_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**CAN GPIO Configuration
    PA11     ------> CAN_RX
    PA12     ------> CAN_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* CAN1 interrupt Init */
    HAL_NVIC_SetPriority(USB_HP_CAN1_TX_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USB_HP_CAN1_TX_IRQn);
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
  /* USER CODE BEGIN CAN1_MspInit 1 */

  /* USER CODE END CAN1_MspInit 1 */
  }
}

void HAL_CAN_MspDeInit(CAN_HandleTypeDef* canHandle)
{

  if(canHandle->Instance==CAN1)
  {
  /* USER CODE BEGIN CAN1_MspDeInit 0 */

  /* USER CODE END CAN1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_CAN1_CLK_DISABLE();

    /**CAN GPIO Configuration
    PA11     ------> CAN_RX
    PA12     ------> CAN_TX
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11|GPIO_PIN_12);

    /* CAN1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(USB_HP_CAN1_TX_IRQn);
    HAL_NVIC_DisableIRQ(USB_LP_CAN1_RX0_IRQn);
  /* USER CODE BEGIN CAN1_MspDeInit 1 */

  /* USER CODE END CAN1_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/**
  * @brief  控制单个DJI电机
  * @param  motor_id: 电机ID (1-4)
  * @param  current: 电流值 (-16384 到 16384)
  * @retval None
  */
void can_dji_motor_control(uint8_t motor_id, int16_t current)
{
  CAN_TxHeaderTypeDef tx_header;
  uint8_t tx_data[8];
  uint32_t tx_mailbox;
  
  // 设置发送头
  tx_header.StdId = DJI_3508_CAN_ID;
  tx_header.ExtId = 0;
  tx_header.IDE = CAN_ID_STD;
  tx_header.RTR = CAN_RTR_DATA;
  tx_header.DLC = 8;
  
  // 清零数据
  for(int i = 0; i < 8; i++)
  {
    tx_data[i] = 0;
  }
  
  // 根据电机ID设置对应的电流值
  switch(motor_id)
  {
    case 1:
      tx_data[0] = (current >> 8) & 0xFF;
      tx_data[1] = current & 0xFF;
      break;
    case 2:
      tx_data[2] = (current >> 8) & 0xFF;
      tx_data[3] = current & 0xFF;
      break;
    case 3:
      tx_data[4] = (current >> 8) & 0xFF;
      tx_data[5] = current & 0xFF;
      break;
    case 4:
      tx_data[6] = (current >> 8) & 0xFF;
      tx_data[7] = current & 0xFF;
      break;
    default:
      return;
  }
  
  // 发送CAN消息
  if (HAL_CAN_AddTxMessage(&hcan, &tx_header, tx_data, &tx_mailbox) != HAL_OK)
  {
    // 错误处理
    Error_Handler();
  }
}

/**
  * @brief  同时控制四个DJI电机
  * @param  current1: 电机1电流值
  * @param  current2: 电机2电流值
  * @param  current3: 电机3电流值
  * @param  current4: 电机4电流值
  * @retval None
  */
void can_dji_motor_control_multi(int16_t current1, int16_t current2, int16_t current3, int16_t current4)
{
  CAN_TxHeaderTypeDef tx_header;
  uint8_t tx_data[8];
  uint32_t tx_mailbox;
  
  // 设置发送头
  tx_header.StdId = DJI_3508_CAN_ID;
  tx_header.ExtId = 0;
  tx_header.IDE = CAN_ID_STD;
  tx_header.RTR = CAN_RTR_DATA;
  tx_header.DLC = 8;
  
  // 填充数据
  tx_data[0] = (current1 >> 8) & 0xFF;
  tx_data[1] = current1 & 0xFF;
  tx_data[2] = (current2 >> 8) & 0xFF;
  tx_data[3] = current2 & 0xFF;
  tx_data[4] = (current3 >> 8) & 0xFF;
  tx_data[5] = current3 & 0xFF;
  tx_data[6] = (current4 >> 8) & 0xFF;
  tx_data[7] = current4 & 0xFF;
  
  // 发送CAN消息
  if (HAL_CAN_AddTxMessage(&hcan, &tx_header, tx_data, &tx_mailbox) != HAL_OK)
  {
    // 错误处理
    Error_Handler();
  }
}

/**
  * @brief  CAN接收回调函数
  * @param  rx_header: 接收消息头
  * @param  rx_data: 接收数据
  * @retval None
  */
void can_receive_callback(CAN_RxHeaderTypeDef *rx_header, uint8_t rx_data[])
{
  // 处理电机反馈数据
  if(rx_header->StdId >= DJI_3508_FEEDBACK_ID_START && rx_header->StdId <= (DJI_3508_FEEDBACK_ID_START + 4))
  {
    uint8_t motor_id = rx_header->StdId - DJI_3508_FEEDBACK_ID_START;
    
    // 确保电机ID在有效范围内
    if(motor_id >= 1 && motor_id <= 4)
    {
      // 解析反馈数据
      motor_feedback[motor_id-1].angle = (rx_data[0] << 8) | rx_data[1];
      motor_feedback[motor_id-1].speed = (rx_data[2] << 8) | rx_data[3];
      motor_feedback[motor_id-1].current = (rx_data[4] << 8) | rx_data[5];
      motor_feedback[motor_id-1].temp = (rx_data[6] << 8) | rx_data[7];
    }
  }
}

/**
  * @brief  初始化PID控制器
  * @param  pid: PID控制器结构体指针
  * @param  kp: 比例系数
  * @param  ki: 积分系数
  * @param  kd: 微分系数
  * @retval None
  */
void pid_init(pid_controller_t *pid, float kp, float ki, float kd)
{
  pid->kp = kp;
  pid->ki = ki;
  pid->kd = kd;
  pid->target = 0.0f;
  pid->current = 0.0f;
  pid->error = 0.0f;
  pid->last_error = 0.0f;
  pid->integral = 0.0f;
  pid->output = 0.0f;
}

/**
  * @brief  PID计算
  * @param  pid: PID控制器结构体指针
  * @param  target: 目标值
  * @param  current: 当前值
  * @retval PID输出值
  */
float pid_calculate(pid_controller_t *pid, float target, float current)
{
  pid->target = target;
  pid->current = current;
  pid->error = target - current;
  
  // 积分项
  pid->integral += pid->error;
  
  // 积分限幅，防止积分饱和
  if(pid->integral > 10000.0f)
    pid->integral = 10000.0f;
  else if(pid->integral < -10000.0f)
    pid->integral = -10000.0f;
  
  // 微分项
  float derivative = pid->error - pid->last_error;
  
  // PID输出
  pid->output = pid->kp * pid->error + pid->ki * pid->integral + pid->kd * derivative;
  
  // 输出限幅
  if(pid->output > 16384.0f)
    pid->output = 16384.0f;
  else if(pid->output < -16384.0f)
    pid->output = -16384.0f;
  
  pid->last_error = pid->error;
  
  return pid->output;
}

/* USER CODE END 1 */
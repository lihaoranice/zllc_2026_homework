/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    usart.c
  * @brief   This file provides code for the configuration
  *          of the USART instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "usart.h"
#include "gpio.h"

/* USER CODE BEGIN 0 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "motor_control.h"

// 串口接收缓冲区
static uint8_t uart_rx_buffer[UART_RX_BUFFER_SIZE];
static uint8_t uart_rx_byte;
static uint16_t uart_rx_index = 0;

// 控制模式某识：0=PS2手柄模式, 1=上位机控制模式
extern uint8_t control_mode;

/* USER CODE END 0 */

UART_HandleTypeDef huart3;

/* USART3 init function */

void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(uartHandle->Instance==USART3)
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* USART3 clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**USART3 GPIO Configuration
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }
}

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART3)
  {
  /* USER CODE BEGIN USART3_MspDeInit 0 */

  /* USER CODE END USART3_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_USART3_CLK_DISABLE();

    /**USART3 GPIO Configuration
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);

  /* USER CODE BEGIN USART3_MspDeInit 1 */

  /* USER CODE END USART3_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/**
  * @brief  printf重定向
  */
int fputc(int ch, FILE *f)
{
    HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 0xFFFF);
    return ch;
}

/**
  * @brief  启动串口中断接收
  */
void UART_IT_Enable(void)
{
	HAL_UART_Receive_IT(&huart3, &uart_rx_byte, 1);
}

/**
  * @brief  串口接收中断回调函数
  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	if(huart->Instance == USART3)
	{
		// 判断是否为帧尾（\n或\r）
		if(uart_rx_byte == '\n' || uart_rx_byte == '\r')
		{
			if(uart_rx_index > 0)
			{
				uart_rx_buffer[uart_rx_index] = '\0';  // 字符串结束符
				UART_Process_Command();  // 处理命令
				uart_rx_index = 0;  // 重置索引
			}
		}
		else
		{
			// 存储数据
			if(uart_rx_index < UART_RX_BUFFER_SIZE - 1)
			{
				uart_rx_buffer[uart_rx_index++] = uart_rx_byte;
			}
			else
			{
				// 缓冲区溢出，重置
				uart_rx_index = 0;
			}
		}
		
		// 继续接收
		HAL_UART_Receive_IT(&huart3, &uart_rx_byte, 1);
	}
}

/**
  * @brief  处理上位机命令
  * @命令格式：
  *   手动控制：  CMD:MOVE,<方向>,<速度>   例如: CMD:MOVE,F,500
  *   自动寻路：  CMD:AUTO,<路径>         例如: CMD:AUTO,F500,R90,F300
  *   停止：      CMD:STOP
  *   查询状态：  CMD:STATUS
  *   复位编码器：CMD:RESET_ENC
  *   切换模式：  CMD:MODE,<0|1>  (0=PS2, 1=UART)
  */
void UART_Process_Command(void)
{
	char *token;
	char buffer[UART_RX_BUFFER_SIZE];
	strcpy(buffer, (char*)uart_rx_buffer);
	
	// 解析命令头
	token = strtok(buffer, ":");
	if(token == NULL || strcmp(token, "CMD") != 0)
	{
		printf("ERROR: Invalid command format\r\n");
		return;
	}
	
	// 解析命令类型
	token = strtok(NULL, ",");
	if(token == NULL)
	{
		printf("ERROR: No command type\r\n");
		return;
	}
	
	// 处理移动命令
	if(strcmp(token, "MOVE") == 0)
	{
		char *direction = strtok(NULL, ",");
		char *speed_str = strtok(NULL, ",");
		
		if(direction == NULL || speed_str == NULL)
		{
			printf("ERROR: Invalid MOVE command\r\n");
			return;
		}
		
		int16_t speed = atoi(speed_str);
		
		// 限制速度范围
		if(speed < MIN_PWM) speed = MIN_PWM;
		if(speed > MAX_PWM) speed = MAX_PWM;
		
		if(strcmp(direction, "F") == 0)  // Forward
		{
			Car_Forward(speed);
			printf("OK: Moving forward at %d\r\n", speed);
		}
		else if(strcmp(direction, "B") == 0)  // Backward
		{
			Car_Backward(speed);
			printf("OK: Moving backward at %d\r\n", speed);
		}
		else if(strcmp(direction, "L") == 0)  // Turn Left
		{
			Car_TurnLeft(speed);
			printf("OK: Turning left at %d\r\n", speed);
		}
		else if(strcmp(direction, "R") == 0)  // Turn Right
		{
			Car_TurnRight(speed);
			printf("OK: Turning right at %d\r\n", speed);
		}
		else
		{
			printf("ERROR: Invalid direction\r\n");
		}
	}
	// 处理停止命令
	else if(strcmp(token, "STOP") == 0)
	{
		Car_Stop();
		printf("OK: Car stopped\r\n");
	}
	// 处理状态查询命令
	else if(strcmp(token, "STATUS") == 0)
	{
		UART_SendCarStatus();
	}
	// 复位编码器
	else if(strcmp(token, "RESET_ENC") == 0)
	{
		Encoder_ResetCounts();
		printf("OK: Encoder reset\r\n");
	}
	// 切换控制模式
	else if(strcmp(token, "MODE") == 0)
	{
		char *mode_str = strtok(NULL, ",");
		if(mode_str == NULL)
		{
			printf("ERROR: No mode specified\r\n");
			return;
		}
		
		uint8_t mode = atoi(mode_str);
		if(mode == 0 || mode == 1)
		{
			control_mode = mode;
			printf("OK: Mode set to %d (%s)\r\n", mode, mode == 0 ? "PS2" : "UART");
		}
		else
		{
			printf("ERROR: Invalid mode (0=PS2, 1=UART)\r\n");
		}
	}
	else
	{
		printf("ERROR: Unknown command\r\n");
	}
}

/**
  * @brief  发送小车状态
  */
void UART_SendCarStatus(void)
{
	int32_t left_enc = Encoder_GetLeftCount();
	int32_t right_enc = Encoder_GetRightCount();
	
	printf("STATUS: LeftEnc=%ld, RightEnc=%ld, Mode=%d\r\n", 
	       left_enc, right_enc, control_mode);
}

/* USER CODE END 1 */

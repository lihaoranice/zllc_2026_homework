# PS2混合小车上位机控制说明

## 系统概述

本系统是基于STM32F103C8T6的智能小车控制系统，支持两种控制模式：
- **PS2手柄控制模式**：通过PS2无线手柄实时控制小车运动
- **上位机控制模式**：通过串口接收上位机命令，实现自动寻路和精确控制

## 硬件配置

### 主控芯片
- STM32F103C8T6（72MHz主频）

### 电机驱动
- 4个JGB37-520带编码器直流电机
- 2个L298N电机驱动模块
- PWM控制（TIM1 CH1/CH2）

### 传感器
- 编码器反馈（TIM2/TIM3编码器模式）

### 通信接口
- USART3：115200波特率，8位数据位，1位停止位，无校验
- 引脚：PB10(TX)，PB11(RX)

### PS2手柄接口
- PB12: DI（数据输入）
- PB13: CMD（命令）
- PB14: CS（片选）
- PB15: CLK（时钟）

## 串口通信协议

### 通信参数
- **波特率**：115200
- **数据位**：8
- **停止位**：1
- **校验位**：无
- **流控**：无

### 命令格式

所有命令采用ASCII文本格式，以换行符（`\n`）或回车符（`\r`）结束。

#### 1. 移动控制命令

**格式**：`CMD:MOVE,<方向>,<速度>`

**参数说明**：
- `<方向>`：
  - `F` - 前进（Forward）
  - `B` - 后退（Backward）
  - `L` - 原地左转（Turn Left）
  - `R` - 原地右转（Turn Right）
- `<速度>`：PWM值，范围 150-900
  - 150：最小速度
  - 900：最大速度
  - 建议值：300-600

**示例**：
```
CMD:MOVE,F,500   # 以速度500前进
CMD:MOVE,B,400   # 以速度400后退
CMD:MOVE,L,300   # 以速度300原地左转
CMD:MOVE,R,300   # 以速度300原地右转
```

**返回**：
```
OK: Moving forward at 500
OK: Moving backward at 400
OK: Turning left at 300
OK: Turning right at 300
```

#### 2. 停止命令

**格式**：`CMD:STOP`

**说明**：立即停止小车所有运动

**示例**：
```
CMD:STOP
```

**返回**：
```
OK: Car stopped
```

#### 3. 状态查询命令

**格式**：`CMD:STATUS`

**说明**：查询小车当前状态，包括编码器计数和控制模式

**示例**：
```
CMD:STATUS
```

**返回**：
```
STATUS: LeftEnc=12345, RightEnc=12340, Mode=1
```

**返回参数说明**：
- `LeftEnc`：左侧编码器累计计数
- `RightEnc`：右侧编码器累计计数
- `Mode`：当前控制模式（0=PS2，1=UART）

#### 4. 编码器复位命令

**格式**：`CMD:RESET_ENC`

**说明**：将左右编码器计数清零

**示例**：
```
CMD:RESET_ENC
```

**返回**：
```
OK: Encoder reset
```

#### 5. 模式切换命令

**格式**：`CMD:MODE,<模式>`

**参数说明**：
- `<模式>`：
  - `0` - PS2手柄控制模式
  - `1` - 上位机串口控制模式

**示例**：
```
CMD:MODE,0   # 切换到PS2手柄模式
CMD:MODE,1   # 切换到上位机模式
```

**返回**：
```
OK: Mode set to 0 (PS2)
OK: Mode set to 1 (UART)
```

**注意**：在PS2模式下，串口命令将不会控制小车运动，但仍可查询状态

## 错误处理

当命令格式错误或参数无效时，系统会返回错误信息：

```
ERROR: Invalid command format    # 命令格式错误
ERROR: No command type           # 缺少命令类型
ERROR: Invalid MOVE command      # 移动命令参数错误
ERROR: Invalid direction         # 无效的方向参数
ERROR: Unknown command           # 未知命令
ERROR: No mode specified         # 未指定模式
ERROR: Invalid mode (0=PS2, 1=UART)  # 无效的模式参数
```

## 上位机编程示例

### Python示例

```python
import serial
import time

class CarController:
    def __init__(self, port='COM3', baudrate=115200):
        """
        初始化小车控制器
        :param port: 串口号
        :param baudrate: 波特率
        """
        self.ser = serial.Serial(port, baudrate, timeout=1)
        time.sleep(2)  # 等待连接稳定
        
    def send_command(self, command):
        """
        发送命令并接收响应
        :param command: 命令字符串
        :return: 响应字符串
        """
        self.ser.write((command + '\n').encode())
        time.sleep(0.1)
        response = self.ser.readline().decode().strip()
        return response
    
    def move_forward(self, speed=500):
        """前进"""
        return self.send_command(f'CMD:MOVE,F,{speed}')
    
    def move_backward(self, speed=500):
        """后退"""
        return self.send_command(f'CMD:MOVE,B,{speed}')
    
    def turn_left(self, speed=300):
        """原地左转"""
        return self.send_command(f'CMD:MOVE,L,{speed}')
    
    def turn_right(self, speed=300):
        """原地右转"""
        return self.send_command(f'CMD:MOVE,R,{speed}')
    
    def stop(self):
        """停止"""
        return self.send_command('CMD:STOP')
    
    def get_status(self):
        """获取状态"""
        return self.send_command('CMD:STATUS')
    
    def reset_encoder(self):
        """复位编码器"""
        return self.send_command('CMD:RESET_ENC')
    
    def set_mode(self, mode):
        """
        设置控制模式
        :param mode: 0=PS2, 1=UART
        """
        return self.send_command(f'CMD:MODE,{mode}')
    
    def close(self):
        """关闭串口"""
        self.ser.close()

# 使用示例
if __name__ == '__main__':
    # 创建控制器实例
    car = CarController('COM3')
    
    try:
        # 切换到上位机控制模式
        print(car.set_mode(1))
        time.sleep(0.5)
        
        # 复位编码器
        print(car.reset_encoder())
        time.sleep(0.5)
        
        # 前进2秒
        print(car.move_forward(500))
        time.sleep(2)
        
        # 停止
        print(car.stop())
        time.sleep(0.5)
        
        # 右转90度（需要根据实际情况调整时间）
        print(car.turn_right(300))
        time.sleep(0.8)
        
        # 停止
        print(car.stop())
        time.sleep(0.5)
        
        # 前进1秒
        print(car.move_forward(500))
        time.sleep(1)
        
        # 停止
        print(car.stop())
        
        # 查询状态
        print(car.get_status())
        
    finally:
        car.close()
```

### C#示例

```csharp
using System;
using System.IO.Ports;
using System.Threading;

public class CarController
{
    private SerialPort serialPort;
    
    public CarController(string portName = "COM3", int baudRate = 115200)
    {
        serialPort = new SerialPort(portName, baudRate);
        serialPort.Open();
        Thread.Sleep(2000);  // 等待连接稳定
    }
    
    public string SendCommand(string command)
    {
        serialPort.WriteLine(command);
        Thread.Sleep(100);
        return serialPort.ReadLine();
    }
    
    public string MoveForward(int speed = 500)
    {
        return SendCommand($"CMD:MOVE,F,{speed}");
    }
    
    public string MoveBackward(int speed = 500)
    {
        return SendCommand($"CMD:MOVE,B,{speed}");
    }
    
    public string TurnLeft(int speed = 300)
    {
        return SendCommand($"CMD:MOVE,L,{speed}");
    }
    
    public string TurnRight(int speed = 300)
    {
        return SendCommand($"CMD:MOVE,R,{speed}");
    }
    
    public string Stop()
    {
        return SendCommand("CMD:STOP");
    }
    
    public string GetStatus()
    {
        return SendCommand("CMD:STATUS");
    }
    
    public string ResetEncoder()
    {
        return SendCommand("CMD:RESET_ENC");
    }
    
    public string SetMode(int mode)
    {
        return SendCommand($"CMD:MODE,{mode}");
    }
    
    public void Close()
    {
        serialPort.Close();
    }
    
    // 使用示例
    static void Main(string[] args)
    {
        CarController car = new CarController("COM3");
        
        try
        {
            // 切换到上位机模式
            Console.WriteLine(car.SetMode(1));
            Thread.Sleep(500);
            
            // 复位编码器
            Console.WriteLine(car.ResetEncoder());
            Thread.Sleep(500);
            
            // 前进2秒
            Console.WriteLine(car.MoveForward(500));
            Thread.Sleep(2000);
            
            // 停止
            Console.WriteLine(car.Stop());
            Thread.Sleep(500);
            
            // 查询状态
            Console.WriteLine(car.GetStatus());
        }
        finally
        {
            car.Close();
        }
    }
}
```

## 自动寻路示例

### 简单路径规划

```python
def auto_navigation(car, path):
    """
    自动寻路函数
    :param car: CarController实例
    :param path: 路径列表，格式：[('F', 500, 2.0), ('R', 300, 0.8), ...]
                每个元素：(方向, 速度, 持续时间)
    """
    car.set_mode(1)  # 切换到上位机模式
    car.reset_encoder()  # 复位编码器
    
    for direction, speed, duration in path:
        if direction == 'F':
            print(f"前进，速度{speed}，持续{duration}秒")
            car.move_forward(speed)
        elif direction == 'B':
            print(f"后退，速度{speed}，持续{duration}秒")
            car.move_backward(speed)
        elif direction == 'L':
            print(f"左转，速度{speed}，持续{duration}秒")
            car.turn_left(speed)
        elif direction == 'R':
            print(f"右转，速度{speed}，持续{duration}秒")
            car.turn_right(speed)
        
        time.sleep(duration)
        car.stop()
        time.sleep(0.5)  # 停顿0.5秒
        
        # 查询状态
        status = car.get_status()
        print(f"当前状态: {status}")

# 使用示例：走一个正方形
if __name__ == '__main__':
    car = CarController('COM3')
    
    try:
        # 定义正方形路径
        square_path = [
            ('F', 500, 2.0),   # 前进2秒
            ('R', 300, 0.8),   # 右转0.8秒（约90度）
            ('F', 500, 2.0),   # 前进2秒
            ('R', 300, 0.8),   # 右转0.8秒
            ('F', 500, 2.0),   # 前进2秒
            ('R', 300, 0.8),   # 右转0.8秒
            ('F', 500, 2.0),   # 前进2秒
            ('R', 300, 0.8),   # 右转0.8秒
        ]
        
        auto_navigation(car, square_path)
        
    finally:
        car.close()
```

### 基于编码器的精确导航

```python
def navigate_by_encoder(car, target_distance, speed=500):
    """
    基于编码器的精确距离控制
    :param car: CarController实例
    :param target_distance: 目标编码器计数差值
    :param speed: 速度
    """
    car.reset_encoder()
    car.move_forward(speed)
    
    while True:
        status = car.get_status()
        # 解析编码器值
        # STATUS: LeftEnc=12345, RightEnc=12340, Mode=1
        parts = status.split(',')
        left_enc = int(parts[0].split('=')[1])
        
        if abs(left_enc) >= target_distance:
            car.stop()
            break
        
        time.sleep(0.1)
    
    print(f"已移动到目标位置，编码器值：{left_enc}")

# 使用示例
if __name__ == '__main__':
    car = CarController('COM3')
    
    try:
        car.set_mode(1)
        
        # 移动1000个编码器计数
        navigate_by_encoder(car, 1000, 500)
        
    finally:
        car.close()
```

## 常见问题

### Q1: 小车不响应串口命令
**A**: 
1. 检查是否已切换到上位机模式（`CMD:MODE,1`）
2. 确认串口参数正确（115200, 8N1）
3. 检查串口是否被其他程序占用

### Q2: 小车速度不稳定
**A**: 
1. 检查电池电量是否充足
2. 调整PWM值范围（建议300-600）
3. 检查电机和驱动模块连接

### Q3: 编码器计数不准确
**A**: 
1. 检查编码器连接是否牢固
2. 确认TIM2/TIM3配置为编码器模式
3. 定期使用`CMD:RESET_ENC`清零

### Q4: 如何标定转向角度
**A**: 
1. 使用`CMD:MOVE,L,300`测试原地左转
2. 记录转90度所需时间
3. 在程序中使用该时间作为转向参数

### Q5: PS2手柄和串口能同时使用吗
**A**: 
不能。系统同时只能使用一种控制模式，使用`CMD:MODE,<0|1>`切换。

## 技术支持

如有问题，请提供以下信息：
1. 硬件版本和配置
2. 错误信息和返回值
3. 上位机代码片段
4. 串口调试工具截图

---

**版本**：v1.0  
**更新日期**：2025-10-27  
**作者**：PS2 Hybrid Car Control System

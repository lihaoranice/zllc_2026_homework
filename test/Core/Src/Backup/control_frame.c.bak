/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    control_frame.c
  * @brief   18字节控制帧 打包与发送实现
  ******************************************************************************
  */
/* USER CODE END Header */

#include "control_frame.h"

static void set_bits(uint8_t *buf, uint16_t bit_offset, uint8_t bit_len, uint32_t value)
{
  for (uint8_t i = 0; i < bit_len; i++)
  {
    uint16_t bit_pos  = bit_offset + i;
    uint16_t byte_idx = bit_pos / 8U;
    uint8_t  bit_idx  = (uint8_t)(bit_pos % 8U);

    if (value & (1UL << i))
    {
      buf[byte_idx] |= (uint8_t)(1U << bit_idx);
    }
    else
    {
      buf[byte_idx] &= (uint8_t)~(1U << bit_idx);
    }
  }
}

static uint32_t get_bits(const uint8_t *buf, uint16_t bit_offset, uint8_t bit_len)
{
  uint32_t value = 0U;

  for (uint8_t i = 0; i < bit_len; i++)
  {
    uint16_t bit_pos  = bit_offset + i;
    uint16_t byte_idx = bit_pos / 8U;
    uint8_t  bit_idx  = (uint8_t)(bit_pos % 8U);

    uint8_t bit = (uint8_t)((buf[byte_idx] >> bit_idx) & 0x01U);

    if (bit != 0U)
    {
      value |= (1UL << i);
    }
  }

  return value;
}

void ControlFrame_Init(ControlFrame_t *f)
{
  if (f == NULL)
  {
    return;
  }

  f->ch0 = 1024U;
  f->ch1 = 1024U;
  f->ch2 = 1024U;
  f->ch3 = 1024U;

  f->s1 = 3U;
  f->s2 = 3U;

  f->mouse_x = 0;
  f->mouse_y = 0;
  f->mouse_z = 0;

  f->mouse_left  = 0U;
  f->mouse_right = 0U;

  f->key     = 0U;
  f->reserve = 0U;
}

uint16_t Control_Map_Channel_FromFloat(float x)
{
  const float in_min  = -1.0f;
  const float in_max  =  1.0f;
  const float out_min = 364.0f;
  const float out_max = 1684.0f;

  if (x < in_min) x = in_min;
  if (x > in_max) x = in_max;

  float k = (out_max - out_min) / (in_max - in_min);
  float y = out_min + k * (x - in_min);

  if (y < out_min) y = out_min;
  if (y > out_max) y = out_max;

  return (uint16_t)(y + 0.5f);
}

uint16_t Control_Map_Channel_FromADC(uint16_t adc, uint16_t adc_min, uint16_t adc_max)
{
  if (adc_max <= adc_min)
  {
    return 1024U;
  }

  const float out_min = 364.0f;
  const float out_max = 1684.0f;

  if (adc < adc_min) adc = adc_min;
  if (adc > adc_max) adc = adc_max;

  float in_span  = (float)(adc_max - adc_min);
  float out_span = out_max - out_min;

  float y = out_min + out_span * (float)(adc - adc_min) / in_span;

  if (y < out_min) y = out_min;
  if (y > out_max) y = out_max;

  return (uint16_t)(y + 0.5f);
}

uint16_t Control_Map_Channel_FromVoltage(float v)
{
  /* 电压范围 0 ~ 3.6V 映射到 364 ~ 1684 */
  const float in_min  = 0.0f;
  const float in_max  = 3.6f;
  const float out_min = 364.0f;
  const float out_max = 1684.0f;

  if (v < in_min) v = in_min;
  if (v > in_max) v = in_max;

  float k = (out_max - out_min) / (in_max - in_min);
  float y = out_min + k * (v - in_min);

  if (y < out_min) y = out_min;
  if (y > out_max) y = out_max;

  return (uint16_t)(y + 0.5f);
}

int16_t Control_Map_Mouse_FromFloat(float x)
{
  const float in_min  = -1.0f;
  const float in_max  =  1.0f;
  const float out_min = -32768.0f;
  const float out_max =  32767.0f;

  if (x < in_min) x = in_min;
  if (x > in_max) x = in_max;

  float k = (out_max - out_min) / (in_max - in_min);
  float y = out_min + k * (x - in_min);

  if (y < out_min) y = out_min;
  if (y > out_max) y = out_max;

  return (int16_t)(y + (y >= 0.0f ? 0.5f : -0.5f));
}

void ControlFrame_Pack(uint8_t buf[18], const ControlFrame_t *f)
{
  if ((buf == NULL) || (f == NULL))
  {
    return;
  }

  for (int i = 0; i < 18; i++)
  {
    buf[i] = 0U;
  }

  set_bits(buf,   0, 11, (uint16_t)(f->ch0 & 0x07FFU));
  set_bits(buf,  11, 11, (uint16_t)(f->ch1 & 0x07FFU));
  set_bits(buf,  22, 11, (uint16_t)(f->ch2 & 0x07FFU));
  set_bits(buf,  33, 11, (uint16_t)(f->ch3 & 0x07FFU));

  set_bits(buf,  44,  2, (uint8_t)(f->s1 & 0x03U));
  set_bits(buf,  46,  2, (uint8_t)(f->s2 & 0x03U));

  set_bits(buf,  48, 16, (uint16_t)f->mouse_x);
  set_bits(buf,  64, 16, (uint16_t)f->mouse_y);
  set_bits(buf,  80, 16, (uint16_t)f->mouse_z);

  set_bits(buf,  96,  8, (uint8_t)(f->mouse_left  & 0x01U));
  set_bits(buf, 104,  8, (uint8_t)(f->mouse_right & 0x01U));

  set_bits(buf, 112, 16, f->key);
  set_bits(buf, 128, 16, f->reserve);
}

void ControlFrame_Send(UART_HandleTypeDef *huart, ControlFrame_t *f, uint8_t buf[18])
{
  if ((huart == NULL) || (f == NULL) || (buf == NULL))
  {
    return;
  }

  ControlFrame_Pack(buf, f);

  (void)HAL_UART_Transmit(huart, buf, 18U, 100U);
}

void ControlFrame_Decode(const uint8_t buf[18], ControlFrame_t *f)
{
  if ((buf == NULL) || (f == NULL))
  {
    return;
  }

  f->ch0 = (uint16_t)get_bits(buf,   0, 11);
  f->ch1 = (uint16_t)get_bits(buf,  11, 11);
  f->ch2 = (uint16_t)get_bits(buf,  22, 11);
  f->ch3 = (uint16_t)get_bits(buf,  33, 11);

  f->s1  = (uint8_t)get_bits(buf,  44,  2);
  f->s2  = (uint8_t)get_bits(buf,  46,  2);

  f->mouse_x = (int16_t)get_bits(buf, 48, 16);
  f->mouse_y = (int16_t)get_bits(buf, 64, 16);
  f->mouse_z = (int16_t)get_bits(buf, 80, 16);

  f->mouse_left  = (uint8_t)get_bits(buf,  96, 1);
  f->mouse_right = (uint8_t)get_bits(buf, 104, 1);

  f->key     = (uint16_t)get_bits(buf, 112, 16);
  f->reserve = (uint16_t)get_bits(buf, 128, 16);
}

HAL_StatusTypeDef ControlFrame_ReceiveAndDecode(UART_HandleTypeDef *huart,
                                                ControlFrame_t *f,
                                                uint8_t buf[18],
                                                uint32_t timeout)
{
  if ((huart == NULL) || (f == NULL) || (buf == NULL))
  {
    return HAL_ERROR;
  }

  HAL_StatusTypeDef status = HAL_UART_Receive(huart, buf, 18U, timeout);

  if (status == HAL_OK)
  {
    ControlFrame_Decode(buf, f);
  }

  return status;
}


